Okay, this is frustrating! It seems like the attempt to fix the opening flicker accidentally undid the fix for the closing flicker. Let's get this sorted.

Looking at the new code you provided for StockCard.tsx and PortfolioImpactCalculator.tsx:

Analysis - What Went Wrong:

State Management Reverted: The biggest issue is that the previous fix (unifying modal control under a single modalState in StockCard) seems to have been undone or implemented incorrectly by the agent. The code now uses separate states again (isPortfolioImpactOpen for the calculator and isSuccessModalOpen for the success modal) in StockCard.tsx. This inconsistent state management is likely the root cause for both flickers returning/persisting.
Closing Flicker Reintroduced: In the new PortfolioImpactCalculator.tsx, the handleInvest function is back to calling onClose() immediately after triggering the purchase logic (onPurchaseComplete). This is what caused the original closing flicker â€“ the calculator tries to close at the exact same time the parent (StockCard) is trying to open the success modal.
Opening Flicker Persists: Because the state wasn't properly unified, the logic for opening the calculator (handleDragEnd in StockCard.tsx) still uses the potentially problematic direct state setting (debouncedOpenPortfolioImpact which now uses requestAnimationFrame but the core timing issue might remain) concurrently with the card's spring-back animation.
Debugging Plan - Let's Try This (Instructions for Replit Agent):

We need to firmly re-establish the unified state management in StockCard and fix the handleInvest logic again.

Plaintext

**Goal:** Properly implement unified modal state management in `StockCard` and fix the closing logic in `PortfolioImpactCalculator` to resolve both opening and closing flickers on iOS.

**STEP 1: Fix `PortfolioImpactCalculator.tsx` Closing Logic**

1.  **File:** `client/src/components/ui/portfolio-impact-calculator.tsx`
2.  **Modify `handleInvest` Function:**
    * Find the `handleInvest` function.
    * **REMOVE** the line `onClose();` from the *end* of this function. The parent component (`StockCard`) should be responsible for closing the calculator after handling the purchase completion.
    * Ensure the function *only* calls `buyStock(...)` and then `onPurchaseComplete(...)`.

**STEP 2: Implement Unified State in `StockCard.tsx`**

1.  **File:** `client/src/components/ui/stock-card.tsx`
2.  **Remove Old State:** Delete the `isPortfolioImpactOpen` state variable (`useState<boolean>(false);`).
3.  **Add Unified State:** Add the single state variable to manage which modal is shown:
    ```typescript
    const [modalState, setModalState] = useState<'closed' | 'calculator' | 'success'>('closed');
    // Keep purchaseData state if it's already there, otherwise add it:
    const [purchaseData, setPurchaseData] = useState<{ shares: number; amount: number; projectedReturn: number } | null>(null);
    ```
4.  **Modify `handleDragEnd` Function (Right Swipe Logic):**
    * Find the `if (info.offset.x > threshold)` block for the right swipe.
    * **REMOVE** the call to `debouncedOpenPortfolioImpact();`.
    * **Keep** the `cardControls.start({...});` call that animates the card back to the center.
    * **AFTER** the `cardControls.start({...});` call, **ADD** a `setTimeout` to delay opening the calculator modal:
        ```typescript
        // Start spring-back animation first
        cardControls.start({
          x: 0,
          opacity: 1,
          scale: 1,
          transition: { type: "spring", stiffness: 400, damping: 30, duration: 0.4 }
        });

        // THEN, after a short delay, set the modal state to 'calculator'
        setTimeout(() => {
          setModalState('calculator');
        }, 150); // Try 150ms delay

        setSwipeDirection(null);
        ```
5.  **Modify `openPortfolioCalculator` Function:** Change this function to simply set the state:
    ```typescript
    const openPortfolioCalculator = () => {
      setModalState('calculator');
    };
    ```
6.  **Create `handlePurchaseComplete` Function:** (If it doesn't exist from the previous attempt, add it)
    ```typescript
    const handlePurchaseComplete = (data: { shares: number; amount: number; projectedReturn: number }) => {
      setPurchaseData(data);
      setModalState('success'); // <-- Change state to show success modal
    };
    ```
7.  **Create `handleSuccessModalClose` Function:** (If it doesn't exist from the previous attempt, add it)
    ```typescript
    const handleSuccessModalClose = () => {
      setModalState('closed'); // <-- Change state to close modal
      setPurchaseData(null);
      onNext(); // Trigger moving to the next card AFTER closing
    };
    ```
8.  **Update Modal Rendering:** Find where `<PortfolioImpactCalculator ... />` and `<PurchaseSuccessModal ... />` are rendered at the end of the component's return statement. Update the logic to use `modalState`:
    ```typescript
    {/* Portfolio Impact Calculator - Unified state management */}
    {modalState === 'calculator' && (
      <PortfolioImpactCalculator
        isOpen={true} // Controlled by mounting/unmounting via modalState
        onClose={() => setModalState('closed')} // Directly close
        onPurchaseComplete={handlePurchaseComplete} // Pass completion handler
        stock={stock}
      />
    )}
     {/* Purchase Success Modal - Unified state management */}
     {modalState === 'success' && purchaseData && (
       <PurchaseSuccessModal
         isOpen={true} // Controlled by mounting/unmounting via modalState
         onClose={handleSuccessModalClose} // Use specific close handler
         stock={stock}
         shares={purchaseData.shares}
         amount={purchaseData.amount}
         projectedReturn={purchaseData.projectedReturn}
       />
     )}
    ```
    *Make sure `PurchaseSuccessModal` is imported if it isn't already.*

This approach ensures:

A single state (modalState) controls which modal is visible.
The calculator doesn't try to close itself at the same time the success modal opens.
Opening the calculator is slightly delayed after the card swipe animation starts, hopefully preventing the iOS conflict.
Please ask the agent to implement these steps carefully. 